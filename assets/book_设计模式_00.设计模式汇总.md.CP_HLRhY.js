import{_ as t,c as e,o as l,aj as d}from"./chunks/framework._AF764y6.js";const _=JSON.parse('{"title":"设计模式汇总","description":"","frontmatter":{"title":"设计模式汇总","date":"2023-10-24T23:42:24.000Z","permalink":"/design_pattern/summary/","categories":["后端","设计模式"],"tags":["设计模式"]},"headers":[],"relativePath":"book/设计模式/00.设计模式汇总.md","filePath":"book/设计模式/00.设计模式汇总.md","lastUpdated":1744977432000}'),a={name:"book/设计模式/00.设计模式汇总.md"},s=d('<table tabindex="0"><thead><tr><th style="text-align:left;"><strong>类型</strong></th><th style="text-align:left;"><strong>模式名称</strong></th><th style="text-align:left;"><strong>英文名称</strong></th><th style="text-align:left;"><strong>说明</strong></th><th style="text-align:left;"><strong>适用场景</strong></th></tr></thead><tbody><tr><td style="text-align:left;">创建型</td><td style="text-align:left;"><a href="./01.创建型-单例模式">单例</a></td><td style="text-align:left;">Singleton</td><td style="text-align:left;">一个类只允许创建一个实例或对象，并为其提供一个全局的访问点</td><td style="text-align:left;">无状态/全局唯一/控制资源访问</td></tr><tr><td style="text-align:left;">创建型</td><td style="text-align:left;"><a href="./02.创建型-工厂方法模式">工厂方法</a><br><a href="./03.创建型-抽象工厂模式">抽象工厂</a></td><td style="text-align:left;">Factory Method<br>Abstract Factory</td><td style="text-align:left;">创建一个或者多个相关的对象，而使用者不用关心具体的实现类</td><td style="text-align:left;">分离对象的创建和使用</td></tr><tr><td style="text-align:left;">创建型</td><td style="text-align:left;"><a href="./04.创建型-建造者模式">建造者</a></td><td style="text-align:left;">Builder</td><td style="text-align:left;">用于创建一种类型的复杂对象，通过设置不同的可选参数进行“定制化”</td><td style="text-align:left;">对象的构造参数较多且多数可选</td></tr><tr><td style="text-align:left;">创建型</td><td style="text-align:left;"><a href="./05.创建型-原型模式">原型</a></td><td style="text-align:left;">Prototype</td><td style="text-align:left;">通过复制已有对象来创建新的对象</td><td style="text-align:left;">对象的创建成本较大且同一类的不同对象之前差别不大</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./12.结构型-代理模式">代理</a></td><td style="text-align:left;">Proxy</td><td style="text-align:left;">不改变原始类和不使用继承的情况下，通过引入代理类来给原始类附加功能</td><td style="text-align:left;">增加代理访问，比如监控、缓存、限流、事务、RPC</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./11.结构型-装饰者模式">装饰者</a></td><td style="text-align:left;">Decorator</td><td style="text-align:left;">不改变原始类和不使用继承的情况下，通过组合的方式动态扩展原始类的功能</td><td style="text-align:left;">动态扩展类的功能</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./09.结构型-适配器模式">适配器</a></td><td style="text-align:left;">Adapter</td><td style="text-align:left;">不改变原始类的情况下，通过组合的方式使其适配新的接口</td><td style="text-align:left;">复用现有类，但与期望接口不适配</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./08.结构型-桥接模式">桥接</a></td><td style="text-align:left;">Bridge</td><td style="text-align:left;">当类存在多个独立变化的维度时，通过组合的方式使得其可以独立进行扩展</td><td style="text-align:left;">存在多个维度的继承体系时</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./10.结构型-外观模式">门面</a>(外观)</td><td style="text-align:left;">Facade</td><td style="text-align:left;">为子系统中一组接口定义一个更高层的接口，使得子系统更加容易使用</td><td style="text-align:left;">解决接口复用性（细粒度）与接口易用性（粗粒度）的矛盾</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./07.结构型-组合模式">组合</a></td><td style="text-align:left;">Component</td><td style="text-align:left;">将对象组合成树形结构以表示部分-整体的层次结构，统一单个对和组合对象的处理逻辑</td><td style="text-align:left;">满足部分与整体这种树形结构</td></tr><tr><td style="text-align:left;">结构型</td><td style="text-align:left;"><a href="./06.结构型-享元模式">享元</a></td><td style="text-align:left;">Flyweight</td><td style="text-align:left;">运用共享技术有效地支持大量细粒度的对象</td><td style="text-align:left;">当系统存在大量的对象，这些对象的很多字段取值范围固定</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./16.行为型-观察者模式">观察者</a></td><td style="text-align:left;">Observer</td><td style="text-align:left;">多个观察者监听同一主题对象，当主题对象状态发生变化时通知所有观察者，使它们能够自动更新自己</td><td style="text-align:left;">解耦事件创建者与接收者</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./14.行为型-模板方法模式">模板方法</a></td><td style="text-align:left;">Template Method</td><td style="text-align:left;">定义一个操作中算法的骨架，将某些步骤实现延迟到子类中</td><td style="text-align:left;">解决复用与扩展问题</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./13.行为型-策略模式">策略</a></td><td style="text-align:left;">Strategy</td><td style="text-align:left;">定义一组算法类，将每个算法分别封装起来，使得它们可以互相替换</td><td style="text-align:left;">消除各种if-else分支判断 解耦策略的定义、创建、使用</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./20.行为型-状态模式">状态</a></td><td style="text-align:left;">State</td><td style="text-align:left;">允许一个对象在其内部状态改变的时候改变其行为</td><td style="text-align:left;">分离对象的状态与行为</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./17.行为型-责任链模式">职责链</a></td><td style="text-align:left;">Chain of Responsibility</td><td style="text-align:left;">将一组对象连成一条链，请求沿着该链传递，直到某个对象能够处理它为止</td><td style="text-align:left;">解耦请求的发送者与接收者</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./15.行为型-迭代器模式">迭代器</a></td><td style="text-align:left;">Iterator</td><td style="text-align:left;">提供一种方法顺序访问一个集合对象的各个元素，但不暴露该对象的内部表示</td><td style="text-align:left;">解耦集合对象的内部表示与遍历访问</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./21.行为型-访问者模式">访问者</a></td><td style="text-align:left;">Visitor</td><td style="text-align:left;">封装一些作用于某种数据结构中各元素的操作，在不改变数据结构的前提下，定义作用于这些元素的新操作。</td><td style="text-align:left;">分离对象的数据结构与行为</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./19.行为型-备忘录模式">备忘录</a></td><td style="text-align:left;">Memento</td><td style="text-align:left;">在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态</td><td style="text-align:left;">用于对象的备份与恢复</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./18.行为型-命令模式">命令</a></td><td style="text-align:left;">Command</td><td style="text-align:left;">将不同的请求封装成对应的命令对象，对命令的执行进行控制且对使用方透明</td><td style="text-align:left;">用于控制命令的执行，比如异步、延迟、排队、撤销、存储与撤销</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./23.行为型-解释器模式">解释器</a></td><td style="text-align:left;">Interpreter</td><td style="text-align:left;">为某个语言定义它的语法表示，并定义一个解释器来处理这个语法</td><td style="text-align:left;">用于编译器、规则引擎、正则表达式等特定场景</td></tr><tr><td style="text-align:left;">行为型</td><td style="text-align:left;"><a href="./22.行为型-中介者模式">中介</a></td><td style="text-align:left;">Mediator</td><td style="text-align:left;">定义一个单独的中介对象，来封装一组对象之间的交互，避免对象之间的直接交互</td><td style="text-align:left;">使各个对象不需要显式地相互引用，从而使其耦合松散</td></tr></tbody></table>',1),n=[s];function f(i,g,y,r,x,o){return l(),e("div",null,n)}const c=t(a,[["render",f]]);export{_ as __pageData,c as default};
