import{_ as h}from"./chunks/ArticleMetadata.H12JcJLK.js";import{_ as m,E as s,c as g,o as n,j as l,I as t,aj as _,w as e,b as u,e as b,a as f}from"./chunks/framework._AF764y6.js";const y="/assets/hello_algo_mindmap.vc8v6pAa.png",x="/assets/binary_search_dictionary_step1.-NHFPFS5.png",k="/assets/binary_search_dictionary_step2.CV8OrKzu.png",P="/assets/binary_search_dictionary_step3.RO7QqT1I.png",S="/assets/binary_search_dictionary_step4.BmPASTJ5.png",T="/assets/binary_search_dictionary_step5.W3_SiIg4.png",C="/assets/playing_cards_sorting.DixWti2W.png",w="/assets/greedy_change.De5ECwrs.png",V="/assets/relationship_between_data_structure_and_algorithm.z5UbgwGS.png",A="/assets/assembling_blocks.PW7tiFVa.png",G=JSON.parse('{"title":"第1章 初识算法","description":"","frontmatter":{"title":"第1章 初识算法","date":"2024-03-23T14:58:05.000Z","permalink":"/algorithm/introduction/","categories":["技术书籍","Hello算法"],"tags":[null],"author":"Manaphy"},"headers":[],"relativePath":"book/Hello算法/01.初识算法.md","filePath":"book/Hello算法/01.初识算法.md","lastUpdated":1743618064000}'),N={name:"book/Hello算法/01.初识算法.md"},v=l("h1",{id:"第1章-初识算法",tabindex:"-1"},[f("第1章 初识算法 "),l("a",{class:"header-anchor",href:"#第1章-初识算法","aria-label":"Permalink to “第1章 初识算法”"},"​")],-1),I=_('<p>内容结构</p><p><img src="'+y+'" alt=""></p><h2 id="_1-算法无处不在" tabindex="-1">1. 算法无处不在 <a class="header-anchor" href="#_1-算法无处不在" aria-label="Permalink to “1.  算法无处不在”">​</a></h2><p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。</p><p>在正式探讨算法之前，有一个有趣的事实值得分享：<strong>你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了</strong>。下面我将举几个具体的例子来证实这一点。</p><p><strong>例一：查字典</strong>。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 r 的字，通常会按照图 1-1 所示的方式实现。</p><ol><li>翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 r 。</li><li>由于在拼音字母表中 r 位于 m 之后，所以排除字典前半部分，查找范围缩小到后半部分。</li><li>不断重复步骤 <code>1.</code> 和 步骤 <code>2.</code> ，直至找到拼音首字母为 r 的页码为止。</li></ol>',7),$=l("img",{src:x,style:{"margin-top":"20px","max-width":"99%"}},null,-1),B=l("img",{src:k,style:{"margin-top":"20px","max-width":"99%"}},null,-1),D=l("img",{src:P,style:{"margin-top":"20px","max-width":"99%"}},null,-1),E=l("img",{src:S,style:{"margin-top":"20px","max-width":"99%"}},null,-1),H=l("img",{src:T,style:{"margin-top":"20px","max-width":"99%"}},null,-1),O=_('<p>查字典这个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。</p><p><strong>例二：整理扑克</strong>。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如下图所示。</p><ol><li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。</li><li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。</li><li>不断循环步骤 <code>2.</code> ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li></ol><img src="'+C+'" alt="扑克排序步骤"><p>上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。</p><p><strong>例三：货币找零</strong>。假设我们在超市购买了 69 元的商品，给了收银员 100 元，则收银员需要找我们 31 元。他会很自然地完成如下图所示的思考。</p><ol><li>可选项是比 31 元面值更小的货币，包括 1 元、5 元、10 元、20 元。</li><li>从可选项中拿出最大的 20 元，剩余 31−20=11 元。</li><li>从剩余可选项中拿出最大的 10 元，剩余 11−10=1 元。</li><li>从剩余可选项中拿出最大的 1 元，剩余 1−1=0 元。</li><li>完成找零，方案为 20+10+1=31 元。</li></ol><p><img src="'+w+'" alt="货币找零过程"></p><p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。</p><p>小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。</p><h2 id="_2-算法是什么" tabindex="-1">2. 算法是什么 <a class="header-anchor" href="#_2-算法是什么" aria-label="Permalink to “2.  算法是什么”">​</a></h2><h3 id="算法定义" tabindex="-1">算法定义 <a class="header-anchor" href="#算法定义" aria-label="Permalink to “算法定义”">​</a></h3><p>「算法 algorithm」是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p><ul><li>问题是明确的，包含清晰的输入和输出定义。</li><li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li><li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li></ul><h3 id="数据结构定义" tabindex="-1">数据结构定义 <a class="header-anchor" href="#数据结构定义" aria-label="Permalink to “数据结构定义”">​</a></h3><p>「数据结构 data structure」是计算机中组织和存储数据的方式，具有以下设计目标。</p><ul><li>空间占用尽量少，以节省计算机内存。</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li><li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li></ul><p><strong>数据结构设计是一个充满权衡的过程</strong>。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p><ul><li>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</li><li>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</li></ul><h3 id="数据结构与算法的关系" tabindex="-1">数据结构与算法的关系 <a class="header-anchor" href="#数据结构与算法的关系" aria-label="Permalink to “数据结构与算法的关系”">​</a></h3><p>如下图，数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。</p><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul><p><img src="'+V+'" alt=""></p><p>数据结构与算法犹如下图所示的拼装积木。一套积木，除了包含许多零件之外，还附有详细的组装说明书。我们按照说明书一步步操作，就能组装出精美的积木模型。</p><p><img src="'+A+'" alt=""></p><p>两者的详细对应关系如表</p><table tabindex="0"><thead><tr><th style="text-align:left;">数据结构与算法</th><th style="text-align:left;">拼装积木</th></tr></thead><tbody><tr><td style="text-align:left;">输入数据</td><td style="text-align:left;">未拼装的积木</td></tr><tr><td style="text-align:left;">数据结构</td><td style="text-align:left;">积木组织形式，包括形状、大小、连接方式等</td></tr><tr><td style="text-align:left;">算法</td><td style="text-align:left;">把积木拼成目标形态的一系列操作步骤</td></tr><tr><td style="text-align:left;">输出数据</td><td style="text-align:left;">积木模型</td></tr></tbody></table><p>值得说明的是，数据结构与算法是独立于编程语言的。正因如此，本书得以提供基于多种编程语言的实现。</p><div class="tip custom-block"><p class="custom-block-title">&quot;约定俗成的简称&quot;</p><p>在实际讨论时，我们通常会将“数据结构与算法”简称为“算法”。比如众所周知的 LeetCode 算法题目，实际上同时考查数据结构和算法两方面的知识。</p></div><h2 id="_3-小结" tabindex="-1">3. 小结 <a class="header-anchor" href="#_3-小结" aria-label="Permalink to “3. 小结”">​</a></h2><ul><li>算法在日常生活中无处不在，并不是遥不可及的高深知识。实际上，我们已经在不知不觉中学会了许多算法，用以解决生活中的大小问题。</li><li>查字典的原理与二分查找算法相一致。二分查找算法体现了分而治之的重要算法思想。</li><li>整理扑克的过程与插入排序算法非常类似。插入排序算法适合排序小型数据集。</li><li>货币找零的步骤本质上是贪心算法，每一步都采取当前看来最好的选择。</li><li>算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。</li><li>数据结构与算法紧密相连。数据结构是算法的基石，而算法是数据结构发挥作用的舞台。</li><li>我们可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。</li></ul>',31);function U(i,W,q,F,M,R){const p=h,c=s("ClientOnly"),a=s("code-block"),d=s("code-group");return n(),g("div",null,[v,t(c,null,{default:e(()=>{var o,r;return[(((o=i.$frontmatter)==null?void 0:o.aside)??!0)&&(((r=i.$frontmatter)==null?void 0:r.showArticleMetadata)??!0)?(n(),u(p,{key:0,article:i.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),I,t(d,null,{default:e(()=>[t(a,{title:"Step 1",active:""},{default:e(()=>[$]),_:1}),t(a,{title:"Step 2"},{default:e(()=>[B]),_:1}),t(a,{title:"Step 3"},{default:e(()=>[D]),_:1}),t(a,{title:"Step 4"},{default:e(()=>[E]),_:1}),t(a,{title:"Step 5"},{default:e(()=>[H]),_:1})]),_:1}),O])}const J=m(N,[["render",U]]);export{G as __pageData,J as default};
