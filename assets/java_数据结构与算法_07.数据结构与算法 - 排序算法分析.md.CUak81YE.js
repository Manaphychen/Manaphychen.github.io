import{_ as t,c as s,o as i,aj as l}from"./chunks/framework._AF764y6.js";const o=JSON.parse('{"title":"数据结构与算法 - 排序算法分析","description":"","frontmatter":{"title":"数据结构与算法 - 排序算法分析","date":"2023-11-04T11:49:46.000Z","permalink":"/dsa/82f563/","categories":["后端","数据结构与算法"],"tags":["算法"],"author":"Manaphy"},"headers":[],"relativePath":"java/数据结构与算法/07.数据结构与算法 - 排序算法分析.md","filePath":"java/数据结构与算法/07.数据结构与算法 - 排序算法分析.md","lastUpdated":1744977432000}'),a={name:"java/数据结构与算法/07.数据结构与算法 - 排序算法分析.md"},n=l(`<h2 id="六、排序算法" tabindex="-1">六、排序算法 <a class="header-anchor" href="#六、排序算法" aria-label="Permalink to “六、排序算法”">​</a></h2><blockquote><p>排序也称排序算法(Sort Algorithm)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p></blockquote><h3 id="_6-1-排序的分类" tabindex="-1">6.1 排序的分类 <a class="header-anchor" href="#_6-1-排序的分类" aria-label="Permalink to “6.1 排序的分类”">​</a></h3><p><strong>内部排序</strong><br>指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。<br><strong>外部排序法</strong><br><strong>数据量过大</strong>，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。<br><strong>常见的排序算法分类</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2345482/1612023227090-a4ca1926-dea7-469c-a8c0-65b02d96b055.png" alt=""></p><h3 id="_6-2-算法的时间复杂度" tabindex="-1">6.2 算法的时间复杂度 <a class="header-anchor" href="#_6-2-算法的时间复杂度" aria-label="Permalink to “6.2 算法的时间复杂度”">​</a></h3><h4 id="_6-2-1-度量一个程序-算法-执行时间的两种方法" tabindex="-1">6.2.1 度量一个程序(算法)执行时间的两种方法 <a class="header-anchor" href="#_6-2-1-度量一个程序-算法-执行时间的两种方法" aria-label="Permalink to “6.2.1 度量一个程序(算法)执行时间的两种方法”">​</a></h4><p><strong>事后统计的方法</strong><br>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。<br><strong>事前估算的方法</strong><br>通过分析某个算法的时间复杂度来判断哪个算法更优。</p><h4 id="_6-2-2-时间频度" tabindex="-1">6.2.2 时间频度 <a class="header-anchor" href="#_6-2-2-时间频度" aria-label="Permalink to “6.2.2 时间频度”">​</a></h4><blockquote><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度。**记为 T(n)。</p></blockquote><p><strong>举例说明 - 基本案例</strong><br>比如计算 1-100 所有数字之和,  我们设计两种算法</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用for循环计算 T(n)=n+1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接计算 T(n)=1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>举例说明 - 忽略常数项</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"><strong>T(n)=2n+20</strong></th><th style="text-align:left;"><strong>T(n)=2*n</strong></th><th style="text-align:left;"><strong>T(n)=(3n+10)</strong></th><th style="text-align:left;"><strong>T(n)=3n</strong></th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">22</td><td style="text-align:left;">2</td><td style="text-align:left;">13</td><td style="text-align:left;">3</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">24</td><td style="text-align:left;">4</td><td style="text-align:left;">16</td><td style="text-align:left;">6</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">30</td><td style="text-align:left;">10</td><td style="text-align:left;">25</td><td style="text-align:left;">15</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;">36</td><td style="text-align:left;">16</td><td style="text-align:left;">34</td><td style="text-align:left;">24</td></tr><tr><td style="text-align:left;">15</td><td style="text-align:left;">50</td><td style="text-align:left;">30</td><td style="text-align:left;">55</td><td style="text-align:left;">45</td></tr><tr><td style="text-align:left;">30</td><td style="text-align:left;">80</td><td style="text-align:left;">60</td><td style="text-align:left;">100</td><td style="text-align:left;">90</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">220</td><td style="text-align:left;">200</td><td style="text-align:left;">310</td><td style="text-align:left;">300</td></tr><tr><td style="text-align:left;">300</td><td style="text-align:left;">620</td><td style="text-align:left;">600</td><td style="text-align:left;">910</td><td style="text-align:left;">900</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2345482/1612023227053-31db044e-6dba-4b42-8b4a-715be08f2023.png" alt=""><br>结论:<br>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略<br>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</p><p><strong>举例说明 - 忽略低次项</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"><strong>T(n)=2n2+3n+10</strong></th><th style="text-align:left;"><strong>T(n)=2n2</strong></th><th style="text-align:left;"><strong>T(n)=n2+5n+20</strong></th><th style="text-align:left;"><strong>T(n)=n2</strong></th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">15</td><td style="text-align:left;">2</td><td style="text-align:left;">26</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">24</td><td style="text-align:left;">8</td><td style="text-align:left;">34</td><td style="text-align:left;">4</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">75</td><td style="text-align:left;">50</td><td style="text-align:left;">70</td><td style="text-align:left;">25</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;">162</td><td style="text-align:left;">128</td><td style="text-align:left;">124</td><td style="text-align:left;">64</td></tr><tr><td style="text-align:left;">15</td><td style="text-align:left;">505</td><td style="text-align:left;">450</td><td style="text-align:left;">320</td><td style="text-align:left;">225</td></tr><tr><td style="text-align:left;">30</td><td style="text-align:left;">1900</td><td style="text-align:left;">1800</td><td style="text-align:left;">1070</td><td style="text-align:left;">900</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">20310</td><td style="text-align:left;">20000</td><td style="text-align:left;">10520</td><td style="text-align:left;">10000</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2345482/1612023227080-44518ce1-259c-42b1-b3eb-d10cae8cb94c.png" alt=""><br>结论:<br>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10<br>n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20<br><strong>举例说明 - 忽略系数</strong></p><table tabindex="0"><thead><tr><th style="text-align:left;"></th><th style="text-align:left;"><strong>T(n)=3n2+2n</strong></th><th style="text-align:left;"><strong>T(n)=5n2+7n</strong></th><th style="text-align:left;"><strong>T(n)=n3+5n</strong></th><th style="text-align:left;"><strong>T(n)=6n3+4n</strong></th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">5</td><td style="text-align:left;">12</td><td style="text-align:left;">6</td><td style="text-align:left;">10</td></tr><tr><td style="text-align:left;">2</td><td style="text-align:left;">16</td><td style="text-align:left;">34</td><td style="text-align:left;">18</td><td style="text-align:left;">56</td></tr><tr><td style="text-align:left;">5</td><td style="text-align:left;">85</td><td style="text-align:left;">160</td><td style="text-align:left;">150</td><td style="text-align:left;">770</td></tr><tr><td style="text-align:left;">8</td><td style="text-align:left;">208</td><td style="text-align:left;">376</td><td style="text-align:left;">552</td><td style="text-align:left;">3104</td></tr><tr><td style="text-align:left;">15</td><td style="text-align:left;">705</td><td style="text-align:left;">1230</td><td style="text-align:left;">3450</td><td style="text-align:left;">20310</td></tr><tr><td style="text-align:left;">30</td><td style="text-align:left;">2760</td><td style="text-align:left;">4710</td><td style="text-align:left;">27150</td><td style="text-align:left;">162120</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">30200</td><td style="text-align:left;">50700</td><td style="text-align:left;">1000500</td><td style="text-align:left;">6000400</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2345482/1612023227095-e28b71f7-da8b-4652-93e6-565f24bad160.png" alt=""><br>结论:<br>随着n值变大，5n2+7n 和 3n2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。<br>而n3+5n 和 6n3+4n  ，执行曲线分离，说明多少次方式关键</p><h4 id="_6-2-3-时间复杂度" tabindex="-1">6.2.3 时间复杂度 <a class="header-anchor" href="#_6-2-3-时间复杂度" aria-label="Permalink to “6.2.3 时间复杂度”">​</a></h4><ol><li>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ(f(n))  为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li><li>计算时间复杂度的方法 <ul><li>用常数1代替运行时间中的所有加法常数  T(n)=3n²+7n+6  =&gt; T(n)=3n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项  T(n)=3n²+7n+1 =&gt; T(n) = 3n²</li><li>去除最高阶项的系数 T(n) = 3n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></li></ol><h4 id="_6-2-4-常见的时间复杂度" tabindex="-1">6.2.4 常见的时间复杂度 <a class="header-anchor" href="#_6-2-4-常见的时间复杂度" aria-label="Permalink to “6.2.4 常见的时间复杂度”">​</a></h4><ol><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n2)</li><li>立方阶O(n3)</li><li>k次方阶O(nk)</li><li>指数阶O(2n)</li></ol><p>常见的时间复杂度对应的图<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2345482/1612023227088-e6b0b20c-d144-4733-b2cc-16e30abbc955.png" alt=""></p><ul><li>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法</li></ul><h4 id="_6-2-5-时间复杂度案例解析" tabindex="-1">6.2.5 时间复杂度案例解析 <a class="header-anchor" href="#_6-2-5-时间复杂度案例解析" aria-label="Permalink to “6.2.5 时间复杂度案例解析”">​</a></h4><p><strong>常数阶O(1)</strong><br>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j;</span></span></code></pre></div><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p><p><strong>对数阶O(log2n)</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n)</p><p><strong>线性阶O(n)</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p><p><strong>线性对数阶O(nlog2n)</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logN)的代码循环N遍的话，那么它的时间复杂度就是 n*O(logN)，也就是了O(nlogN)</p><p><strong>平方阶O(n2)</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n×n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m×n)</p><p><strong>立方阶O(n³)、K次方阶O(nk)</strong><br>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似</p><h4 id="_6-2-6-平均时间复杂度和最坏时间复杂度" tabindex="-1">6.2.6 平均时间复杂度和最坏时间复杂度 <a class="header-anchor" href="#_6-2-6-平均时间复杂度和最坏时间复杂度" aria-label="Permalink to “6.2.6 平均时间复杂度和最坏时间复杂度”">​</a></h4><p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。<br>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。<br>平均时间复杂度和最坏时间复杂度是否一致，和算法有关</p><table tabindex="0"><thead><tr><th style="text-align:left;"><strong>排序法</strong></th><th style="text-align:left;"><strong>平均时间</strong></th><th style="text-align:left;"><strong>最差情形</strong></th><th style="text-align:left;"><strong>稳定度</strong></th><th style="text-align:left;"><strong>额外空间</strong></th><th style="text-align:left;"><strong>备注</strong></th></tr></thead><tbody><tr><td style="text-align:left;">冒泡</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n小时较好</td></tr><tr><td style="text-align:left;">交换</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">不稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n小时较好</td></tr><tr><td style="text-align:left;">选择</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">不稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n小时较好</td></tr><tr><td style="text-align:left;">插入</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">大部分已排序时较好</td></tr><tr><td style="text-align:left;">基数</td><td style="text-align:left;">O(logRB)</td><td style="text-align:left;">O(logRB)</td><td style="text-align:left;">稳定</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">B是真数(0-9)，R是基数(个十百)</td></tr><tr><td style="text-align:left;">Shell</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">O(ns) 1&lt;s&lt;2</td><td style="text-align:left;">不稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">s是所选分组</td></tr><tr><td style="text-align:left;">快速</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">O(n2)</td><td style="text-align:left;">不稳定</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">n大时较好</td></tr><tr><td style="text-align:left;">归并</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n大时较好</td></tr><tr><td style="text-align:left;">堆</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">O(nlogn)</td><td style="text-align:left;">不稳定</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">n大时较好</td></tr></tbody></table><h3 id="_6-3-算法的空间复杂度" tabindex="-1">6.3 算法的空间复杂度 <a class="header-anchor" href="#_6-3-算法的空间复杂度" aria-label="Permalink to “6.3 算法的空间复杂度”">​</a></h3><p>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。<br>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。<br>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</p>`,47),e=[n];function d(h,p,k,g,r,y){return i(),s("div",null,e)}const f=t(a,[["render",d]]);export{o as __pageData,f as default};
