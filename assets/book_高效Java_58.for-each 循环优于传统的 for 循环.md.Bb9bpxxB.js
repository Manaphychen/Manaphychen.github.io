import{_ as e,c as a,o as t,aj as s}from"./chunks/framework._AF764y6.js";const m=JSON.parse('{"title":"for-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯","description":"","frontmatter":{"title":"for-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯","date":"2023-10-25T01:05:38.000Z","permalink":"/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.html","categories":["æŠ€æœ¯ä¹¦ç±","é«˜æ•ˆJava","é€šç”¨ç¨‹åºè®¾è®¡"],"tags":["é«˜æ•ˆJava"],"author":"Manaphy"},"headers":[],"relativePath":"book/é«˜æ•ˆJava/58.for-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯.md","filePath":"book/é«˜æ•ˆJava/58.for-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯.md","lastUpdated":1743259619000}'),n={name:"book/é«˜æ•ˆJava/58.for-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯.md"},o=s(`<h3 id="item-58-prefer-for-each-loops-to-traditional-for-loops-for-each-å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„-for-å¾ªç¯" tabindex="-1">Item 58: Prefer for-each loops to traditional for loopsï¼ˆfor-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯ï¼‰ <a class="header-anchor" href="#item-58-prefer-for-each-loops-to-traditional-for-loops-for-each-å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„-for-å¾ªç¯" aria-label="Permalink to â€œItem 58: Prefer for-each loops to traditional for loopsï¼ˆfor-each å¾ªç¯ä¼˜äºä¼ ç»Ÿçš„ for å¾ªç¯ï¼‰â€">â€‹</a></h3><p>As discussed in Item 45, some tasks are best accomplished with streams, others with iteration. Here is a traditional for loop to iterate over a collection:</p><p>æ­£å¦‚åœ¨ <a href="/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously">Item-45</a> ä¸­æ‰€è®¨è®ºçš„ï¼Œä¸€äº›ä»»åŠ¡æœ€å¥½ä½¿ç”¨æµæ¥å®Œæˆï¼Œå…¶ä»–ä»»åŠ¡æœ€å¥½ä½¿ç”¨ iterationã€‚ä¸‹é¢æ˜¯ä½¿ç”¨ä¸€ä¸ªä¼ ç»Ÿçš„ for å¾ªç¯æ¥éå†ä¸€ä¸ªé›†åˆï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Not the best way to iterate over a collection!</span></span>
<span class="line"><span>for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {</span></span>
<span class="line"><span>    Element e = i.next();</span></span>
<span class="line"><span>    ... // Do something with e</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>and here is a traditional for loop to iterate over an array:</p><p>è¿™æ˜¯ä½¿ç”¨ä¼ ç»Ÿçš„ for å¾ªç¯æ¥éå†æ•°ç»„ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Not the best way to iterate over an array!</span></span>
<span class="line"><span>for (int i = 0; i &lt; a.length; i++) {</span></span>
<span class="line"><span>    ... // Do something with a[i]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>These idioms are better than while loops (Item 57), but they arenâ€™t perfect. The iterator and the index variables are both just clutterâ€”all you need are the elements. Furthermore, they represent opportunities for error. The iterator occurs three times in each loop and the index variable four, which gives you many chances to use the wrong variable. If you do, there is no guarantee that the compiler will catch the problem. Finally, the two loops are quite different, drawing unnecessary attention to the type of the container and adding a (minor) hassle to changing that type.</p><p>è¿™äº›ä¹ æƒ¯ç”¨æ³•æ¯” while å¾ªç¯æ›´å¥½ï¼ˆ<a href="/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables">Item-57</a>ï¼‰ï¼Œä½†æ˜¯å®ƒä»¬å¹¶ä¸å®Œç¾ã€‚è¿­ä»£å™¨å’Œç´¢å¼•å˜é‡éƒ½å¾ˆæ··ä¹±ï¼ˆä½ åªéœ€è¦å…ƒç´ ï¼‰ã€‚æ­¤å¤–ï¼Œå®ƒä»¬æœ‰å‡ºé”™çš„å¯èƒ½ã€‚è¿­ä»£å™¨åœ¨æ¯ä¸ªå¾ªç¯ä¸­å‡ºç°ä¸‰æ¬¡ï¼Œç´¢å¼•å˜é‡å‡ºç°å››æ¬¡ï¼Œè¿™ä½¿å¾—æœ‰å¾ˆå¤šæœºä¼šä½¿ç”¨åˆ°é”™è¯¯çš„å˜é‡ã€‚å¦‚æœè¿™æ ·åšï¼Œå°±ä¸èƒ½ä¿è¯ç¼–è¯‘å™¨ä¼šæ•æ‰åˆ°é—®é¢˜ã€‚æœ€åï¼Œè¿™ä¸¤ä¸ªå¾ªç¯åŒºåˆ«å¾ˆå¤§ï¼Œï¼ˆç¬¬ä¸€ä¸ªä¾‹å­ï¼‰è¿˜éœ€è¦é¢å¤–æ³¨æ„å®¹å™¨ç±»å‹ï¼Œå¹¶ç»™ç±»å‹è½¬æ¢å¢åŠ å°éº»çƒ¦ã€‚</p><p>The for-each loop (officially known as the â€œenhanced for statementâ€) solves all of these problems. It gets rid of the clutter and the opportunity for error by hiding the iterator or index variable. The resulting idiom applies equally to collections and arrays, easing the process of switching the implementation type of a container from one to the other:</p><p>for-each å¾ªç¯ï¼ˆå®˜æ–¹ç§°ä¸ºã€Œenhanced for è¯­å¥ã€ï¼‰è§£å†³äº†æ‰€æœ‰è¿™äº›é—®é¢˜ã€‚å®ƒé€šè¿‡éšè—è¿­ä»£å™¨æˆ–ç´¢å¼•å˜é‡æ¥æ¶ˆé™¤æ··ä¹±å’Œå‡ºé”™çš„æœºä¼šã€‚ç”±æ­¤äº§ç”Ÿçš„ä¹ æƒ¯ç”¨æ³•åŒæ ·é€‚ç”¨äºé›†åˆå’Œæ•°ç»„ï¼Œä»è€Œç®€åŒ–äº†å°†å®¹å™¨çš„å®ç°ç±»å‹ä»ä¸€ç§è½¬æ¢ä¸ºå¦ä¸€ç§çš„è¿‡ç¨‹ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// The preferred idiom for iterating over collections and arrays</span></span>
<span class="line"><span>for (Element e : elements) {</span></span>
<span class="line"><span>    ... // Do something with e</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>When you see the colon (ğŸ˜ƒ, read it as â€œin.â€ Thus, the loop above reads as â€œfor each element e in elements.â€ There is no performance penalty for using for-each loops, even for arrays: the code they generate is essentially identical to the code you would write by hand.</p><p>å½“ä½ çœ‹åˆ°å†’å· <code>(:)</code> æ—¶ï¼Œè¯·å°†å…¶è¯»ä½œã€Œinã€ã€‚å› æ­¤ï¼Œä¸Šé¢çš„å¾ªç¯è¯»ä½œã€Œå¯¹å…ƒç´ é›†çš„æ¯ä¸ªå…ƒç´  e è¿›è¡Œæ“ä½œã€ã€‚ä½¿ç”¨ for-each å¾ªç¯ä¸ä¼šé™ä½æ€§èƒ½ï¼Œå¯¹äºæ•°ç»„ä¹Ÿæ˜¯å¦‚æ­¤ï¼šå®ƒä»¬ç”Ÿæˆçš„ä»£ç æœ¬è´¨ä¸Šä¸ä½ æ‰‹å·¥ç¼–å†™çš„ for å¾ªç¯ä»£ç ç›¸åŒã€‚</p><p>The advantages of the for-each loop over the traditional for loop are even greater when it comes to nested iteration. Here is a common mistake that people make when doing nested iteration:</p><p>å½“æ¶‰åŠåˆ°åµŒå¥—è¿­ä»£æ—¶ï¼Œfor-each å¾ªç¯ç›¸å¯¹äºä¼ ç»Ÿ for å¾ªç¯çš„ä¼˜åŠ¿ç”šè‡³æ›´å¤§ã€‚ä¸‹é¢æ˜¯äººä»¬åœ¨è¿›è¡ŒåµŒå¥—è¿­ä»£æ—¶ç»å¸¸çŠ¯çš„ä¸€ä¸ªé”™è¯¯ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Can you spot the bug?</span></span>
<span class="line"><span>enum Suit { CLUB, DIAMOND, HEART, SPADE }</span></span>
<span class="line"><span>enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,NINE, TEN, JACK, QUEEN, KING }</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>static Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</span></span>
<span class="line"><span>static Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</span></span>
<span class="line"><span>List&lt;Card&gt; deck = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>for (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); )</span></span>
<span class="line"><span>for (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )</span></span>
<span class="line"><span>deck.add(new Card(i.next(), j.next()));</span></span></code></pre></div><p>Donâ€™t feel bad if you didnâ€™t spot the bug. Many expert programmers have made this mistake at one time or another. The problem is that the next method is called too many times on the iterator for the outer collection (suits). It should be called from the outer loop so that it is called once per suit, but instead it is called from the inner loop, so it is called once per card. After you run out of suits, the loop throws a NoSuchElementException.</p><p>å¦‚æœä½ æ²¡æœ‰å‘ç°è¿™ä¸ªbugï¼Œä¸è¦æ„Ÿåˆ°éš¾è¿‡ã€‚è®¸å¤šä¸“ä¸šç¨‹åºå‘˜éƒ½æ›¾çŠ¯è¿‡è¿™æ ·çš„é”™è¯¯ã€‚é—®é¢˜æ˜¯ï¼Œè¿­ä»£å™¨å¯¹å¤–éƒ¨çš„é›†åˆ suits è°ƒç”¨äº†å¤ªå¤šæ¬¡ next æ–¹æ³•ã€‚å®ƒåº”è¯¥ä»å¤–éƒ¨å¾ªç¯è°ƒç”¨ï¼Œå› æ­¤æ¯ç§èŠ±è‰²è°ƒç”¨ä¸€æ¬¡ï¼Œä½†å®ƒæ˜¯ä»å†…éƒ¨å¾ªç¯è°ƒç”¨çš„ï¼Œå› æ­¤æ¯ä¸€å¼ ç‰Œè°ƒç”¨ä¸€æ¬¡ã€‚åœ¨ç”¨å®Œæ‰€æœ‰èŠ±è‰²ä¹‹åï¼Œå¾ªç¯æŠ›å‡º NoSuchElementExceptionã€‚</p><p>If youâ€™re really unlucky and the size of the outer collection is a multiple of the size of the inner collectionâ€”perhaps because theyâ€™re the same collectionâ€”the loop will terminate normally, but it wonâ€™t do what you want. For example, consider this ill-conceived attempt to print all the possible rolls of a pair of dice:</p><p>å¦‚æœçœŸçš„å¾ˆä¸å¹¸ï¼Œå¤–éƒ¨é›†åˆçš„å¤§å°æ˜¯å†…éƒ¨é›†åˆå¤§å°çš„å‡ å€ï¼ˆå¯èƒ½å› ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„é›†åˆï¼‰ï¼Œå¾ªç¯å°†æ­£å¸¸ç»ˆæ­¢ï¼Œä½†æ˜¯å®ƒä¸ä¼šæ‰§è¡Œä½ æƒ³è¦çš„æ“ä½œã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªæ‰“å°ä¸€å¯¹éª°å­æ‰€æœ‰å¯èƒ½çš„ç»„åˆå€¼çš„é”™è¯¯å°è¯•ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Same bug, different symptom!</span></span>
<span class="line"><span>enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>Collection&lt;Face&gt; faces = EnumSet.allOf(Face.class);</span></span>
<span class="line"><span>for (Iterator&lt;Face&gt; i = faces.iterator(); i.hasNext(); )</span></span>
<span class="line"><span>for (Iterator&lt;Face&gt; j = faces.iterator(); j.hasNext(); )</span></span>
<span class="line"><span>System.out.println(i.next() + &quot; &quot; + j.next());</span></span></code></pre></div><p>The program doesnâ€™t throw an exception, but it prints only the six â€œdoublesâ€ (from â€œONE ONEâ€ to â€œSIX SIXâ€), instead of the expected thirty-six combinations.</p><p>ç¨‹åºä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œä½†å®ƒåªæ‰“å° 6 ä¸ªé‡å¤æ•°å€¼ï¼ˆä»ã€ŒONE ONEã€åˆ°ã€ŒSIX SIXã€ï¼‰ï¼Œè€Œä¸æ˜¯é¢„æœŸçš„ 36 ä¸ªç»„åˆã€‚</p><p>To fix the bugs in these examples, you must add a variable in the scope of the outer loop to hold the outer element:</p><p>è¦ä¿®å¤è¿™äº›ä¾‹å­ä¸­çš„é”™è¯¯ï¼Œå¿…é¡»åœ¨å¤–éƒ¨å¾ªç¯çš„ä½œç”¨åŸŸå†…æ·»åŠ ä¸€ä¸ªå˜é‡æ¥ä¿å­˜å¤–éƒ¨å…ƒç´ ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Fixed, but ugly - you can do better!</span></span>
<span class="line"><span>for (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); ) {</span></span>
<span class="line"><span>    Suit suit = i.next();</span></span>
<span class="line"><span>    for (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )</span></span>
<span class="line"><span>        deck.add(new Card(suit, j.next()));</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If instead you use a nested for-each loop, the problem simply disappears. The resulting code is as succinct as you could wish for:</p><p>ç›¸åï¼Œå¦‚æœä½¿ç”¨åµŒå¥— for-each å¾ªç¯ï¼Œé—®é¢˜å°±ä¼šæ¶ˆå¤±ã€‚ç”Ÿæˆçš„ä»£ç æ›´ç®€æ´ï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>// Preferred idiom for nested iteration on collections and arrays</span></span>
<span class="line"><span>for (Suit suit : suits)</span></span>
<span class="line"><span>for (Rank rank : ranks)</span></span>
<span class="line"><span>deck.add(new Card(suit, rank));</span></span></code></pre></div><p>Unfortunately, there are three common situations where you canâ€™t use foreach:</p><p>ä¸å¹¸çš„æ˜¯ï¼Œæœ‰ä¸‰ç§å¸¸è§çš„æƒ…å†µä½ ä¸åº”ä½¿ç”¨ for-eachï¼š</p><ul><li><strong>Destructive filtering</strong> â€”If you need to traverse a collection removing selected elements, then you need to use an explicit iterator so that you can call its remove method. You can often avoid explicit traversal by using Collectionâ€™s removeIf method, added in Java 8.</li></ul><p><strong>ç ´åæ€§è¿‡æ»¤</strong>ï¼Œå¦‚æœéœ€è¦éå†ä¸€ä¸ªé›†åˆå¹¶åˆ é™¤é€‰å®šå…ƒç´ ï¼Œåˆ™éœ€è¦ä½¿ç”¨æ˜¾å¼çš„è¿­ä»£å™¨ï¼Œä»¥ä¾¿è°ƒç”¨å…¶ remove æ–¹æ³•ã€‚é€šè¿‡ä½¿ç”¨ Collection åœ¨ Java 8 ä¸­æ·»åŠ çš„ removeIf æ–¹æ³•ï¼Œé€šå¸¸å¯ä»¥é¿å…æ˜¾å¼éå†ã€‚</p><ul><li><strong>Transforming</strong> â€”If you need to traverse a list or array and replace some or all of the values of its elements, then you need the list iterator or array index in order to replace the value of an element.</li></ul><p><strong>è½¬æ¢</strong>ï¼Œå¦‚æœéœ€è¦éå†ä¸€ä¸ª List æˆ–æ•°ç»„å¹¶æ›¿æ¢å…¶ä¸­éƒ¨åˆ†æˆ–å…¨éƒ¨å…ƒç´ çš„å€¼ï¼Œé‚£ä¹ˆéœ€è¦ List è¿­ä»£å™¨æˆ–æ•°ç»„ç´¢å¼•æ¥æ›¿æ¢å…ƒç´ çš„å€¼ã€‚</p><ul><li><strong>Parallel iteration</strong> â€”If you need to traverse multiple collections in parallel, then you need explicit control over the iterator or index variable so that all iterators or index variables can be advanced in lockstep (as demonstrated unintentionally in the buggy card and dice examples above). If you find yourself in any of these situations, use an ordinary for loop and be wary of the traps mentioned in this item.</li></ul><p><strong>å¹¶è¡Œè¿­ä»£</strong>ï¼Œå¦‚æœéœ€è¦å¹¶è¡Œéå†å¤šä¸ªé›†åˆï¼Œé‚£ä¹ˆéœ€è¦æ˜¾å¼åœ°æ§åˆ¶è¿­ä»£å™¨æˆ–ç´¢å¼•å˜é‡ï¼Œä»¥ä¾¿æ‰€æœ‰è¿­ä»£å™¨æˆ–ç´¢å¼•å˜é‡éƒ½å¯ä»¥åŒæ­¥æ‰§è¡Œï¼ˆå¦‚ä¸Šè¿°ç‰Œå’Œéª°å­ç¤ºä¾‹ä¸­æ— æ„ä¸­æ¼”ç¤ºçš„é”™è¯¯é‚£æ ·ï¼‰ã€‚å¦‚æœå‘ç°è‡ªå·±å¤„äºè¿™äº›æƒ…å†µä¸­çš„ä»»ä½•ä¸€ç§ï¼Œè¯·ä½¿ç”¨æ™®é€šçš„ for å¾ªç¯ï¼Œå¹¶è­¦æƒ•æœ¬æ¡ç›®ä¸­æåˆ°çš„é™·é˜±ã€‚</p><p>Not only does the for-each loop let you iterate over collections and arrays, it lets you iterate over any object that implements the Iterable interface, which consists of a single method. Here is how the interface looks:</p><p>for-each å¾ªç¯ä¸ä»…å…è®¸éå†é›†åˆå’Œæ•°ç»„ï¼Œè¿˜å…è®¸éå†å®ç° Iterable æ¥å£çš„ä»»ä½•å¯¹è±¡ï¼Œè¯¥æ¥å£ç”±ä¸€ä¸ªæ–¹æ³•ç»„æˆã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code" tabindex="0"><code><span class="line"><span>public interface Iterable&lt;E&gt; {</span></span>
<span class="line"><span>    // Returns an iterator over the elements in this iterable</span></span>
<span class="line"><span>    Iterator&lt;E&gt; iterator();</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>It is a bit tricky to implement Iterable if you have to write your own Iterator implementation from scratch, but if you are writing a type that represents a group of elements, you should strongly consider having it implement Iterable, even if you choose not to have it implement Collection. This will allow your users to iterate over your type using the foreach loop, and they will be forever grateful.</p><p>å¦‚æœå¿…é¡»ä»å¤´å¼€å§‹ç¼–å†™è‡ªå·±çš„ Iterator å®ç°ï¼Œç¡®å®æœ‰ç‚¹æ£˜æ‰‹ï¼Œä½†æ˜¯å¦‚æœæ­£åœ¨ç¼–å†™çš„ç±»å‹è¡¨ç¤ºä¸€ç»„å…ƒç´ ï¼Œå³ä½¿é€‰æ‹©ä¸è®©å®ƒå®ç° Collectionï¼Œé‚£ä¹ˆä¹Ÿåº”è¯¥å¼ºçƒˆè€ƒè™‘è®©å®ƒå®ç° Iterableã€‚è¿™å°†å…è®¸ç”¨æˆ·ä½¿ç”¨ foreach å¾ªç¯éå†ç±»å‹ï¼Œä»–ä»¬å°†æ°¸è¿œæ„Ÿæ¿€ä¸å°½ã€‚</p><p>In summary, the for-each loop provides compelling advantages over the traditional for loop in clarity, flexibility, and bug prevention, with no performance penalty. Use for-each loops in preference to for loops wherever you can.</p><p>æ€»ä¹‹ï¼Œfor-each å¾ªç¯åœ¨æ¸…æ™°åº¦ã€çµæ´»æ€§å’Œ bug é¢„é˜²æ–¹é¢æ¯”ä¼ ç»Ÿçš„ for å¾ªç¯æ›´æœ‰ä¼˜åŠ¿ï¼Œå¹¶ä¸”æ²¡æœ‰æ€§èƒ½æŸå¤±ã€‚å°½å¯èƒ½ä½¿ç”¨ for-each å¾ªç¯è€Œä¸æ˜¯ for å¾ªç¯ã€‚</p><hr><p><strong><a href="/Chapter-9/Chapter-9-Introduction">Back to contents of the chapterï¼ˆè¿”å›ç« èŠ‚ç›®å½•ï¼‰</a></strong></p><ul><li><strong>Previous Itemï¼ˆä¸Šä¸€æ¡ç›®ï¼‰ï¼š<a href="/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables">Item 57: Minimize the scope of local variablesï¼ˆå°†å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸæœ€å°åŒ–ï¼‰</a></strong></li><li><strong>Next Itemï¼ˆä¸‹ä¸€æ¡ç›®ï¼‰ï¼š<a href="/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries">Item 59: Know and use the librariesï¼ˆäº†è§£å¹¶ä½¿ç”¨åº“ï¼‰</a></strong></li></ul>`,48),i=[o];function r(l,p,c,h,d,u){return t(),a("div",null,i)}const g=e(n,[["render",r]]);export{m as __pageData,g as default};
