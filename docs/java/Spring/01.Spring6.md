---
title: Spring6
date: 2023-10-31 10:22:36
permalink: /spring/spring6/
categories:
  - 后端
  - Spring
tags:
  - spring
author: Manaphy
---
# 一、Spring简介
## 1.1 概述
> Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。
>
> Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。
>
> 自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。

## 1.2 Spring Framework特点

- **非侵入式**：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。
- **控制反转**：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。
- **面向切面编程**：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。
- **容器**：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。
- **组件化**：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。
- **一站式**：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。
## 1.3 Spring模块组成
**①Spring Core（核心容器）**

spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。

- spring-core ：IOC和DI的基本实现
- spring-beans：BeanFactory和Bean的装配管理(BeanFactory)
- spring-context：Spring context上下文，即IOC容器(AppliactionContext)
- spring-expression：spring表达式语言

**②Spring AOP**

- spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy
- spring-aspects：集成AspectJ，AOP应用框架
- spring-instrument：动态Class Loading模块

**③Spring Data Access**

- spring-jdbc：spring对JDBC的封装，用于简化jdbc操作
- spring-orm：java对象与数据库数据的映射框架
- spring-oxm：对象与xml文件的映射框架
- spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信
- spring-tx：spring jdbc事务管理

**④Spring Web**

- spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器
- spring-webmvc：实现web mvc
- spring-websocket：与前端的全双工通信协议
- spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务

**⑤Spring Message**

- Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务

**⑥Spring test**

- spring-test：集成测试支持，主要是对junit的封装
# 二、容器：IoC
> IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。
>
> Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。
>
> IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。

## 2.1 IoC容器
### 2.1.1 控制反转（IoC）

- 控制反转是一种思想。
- 控制反转是为了降低程序耦合度，提高程序扩展力。
- 控制反转，反转的是什么？
   - 将对象的创建权利交出去，交给第三方容器负责。
   - 将对象和对象之间关系的维护权交出去，交给第三方容器负责。
- 控制反转这种思想如何实现呢？
   - DI（Dependency Injection）：依赖注入
### 2.1.2 依赖注入
DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。

**依赖注入：**

- **指Spring创建对象的过程中，将对象依赖属性通过配置进行注入**

依赖注入常见的实现方式包括两种：

- 第一种：set注入
- 第二种：构造注入

所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。

**Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。**

### 2.1.3 IoC容器在Spring的实现
Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式：

**①BeanFactory**

这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。

**②ApplicationContext**

BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。

**③ApplicationContext的主要实现类**

![img005.png](./assets/HeuloT.png)

| **类型名** | **简介** |
| :-- | :-- |
| ClassPathXmlApplicationContext | 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 |
| FileSystemXmlApplicationContext | 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 |
| ConfigurableApplicationContext | ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。 |
| WebApplicationContext | 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 |

## 2.2 基于XML管理Bean
准备要被管理的对象
```java
@Data
public class User {
   private  Integer uid;
   private  String name;
   private String password;
}
```
配置bean
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                        http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--
    id: 唯一标识
    class：类全路径
    默认使用无参构造
       -->
    <bean id="user" class="ioc.User"/>
</beans>
```
测试
```java
@Test
public void test() {
    // 1.加载spring配置文件
    BeanFactory context = new ClassPathXmlApplicationContext("bean.xml");
    // 2.获取配置创建的对象
    // 2.1 根据id获取
    User user = (User)context.getBean("user");
    // 2.2 根据类型获取
    User user = context.getBean(User.class);
    // 2.3 根据id和类型
    User user = context.getBean("user", User.class);
    
    user.setName("jack");
    System.out.println(user);
}
```
### bean标签和属性讲解
bean标签:是根标签beans内部必须包含的标签,它是用于声明具体的类的对象!

bean标签对应的属性

| **Property** | **属性解释** |
| :-- | :-- |
| class | 指定bean对应类的全路径 |
| name | name是bean对应对象的一个标识 |
| scope | 执行bean对象创建模式和生命周期 |
| id | id是bean对象的唯一标识,不能添加特别字符 |
| lazy-init | 是否延时加载 默认值:false |
| init-method | 对象初始化方法 |
| destroy-method | 对象销毁方法 |

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>
   <!--
   name 可以重复,可以使用特殊字符
   id是唯一的 通过id值可以找到该类的实例 不能使用特殊字符 作用和name几乎相同
   class:类的全路径
   默认使用无参构造
   scope:默认是singleton单例的 如果想使用多例的:scope="prototype"
   lazy-init:false 默认false 只对单例有效,设置单例时使用 加载配置文件就会创建该实例
   lazy-init:true 延迟初始化,在用到对象的时候才会创建对象
   init-method="init"配置初始化方法
   destroy-method="des"配置销毁方法
   -->
   <bean name="user" id="user" class="cgp.model.User" scope="singleton" lazy-init="true" init-method="init" destroy-method="des"/>

   <!--
   静态工厂模式
   class:工厂的类
   factory-method:工厂的静态方法
   -->
   <bean id="user2" class="cgp.model.UserFactory" factory-method="getUser"/>

   <!--
   非静态工厂模式:
   class:工厂的类
   factory-method:工厂的静态方法
   factory-bean:工厂的实例的id
   -->
   <bean id="fac" class="cgp.model.UserFactory"/>
   <bean id="user3" factory-bean="fac" factory-method="getUser2"/>
</beans>
```
### 依赖注入
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>
   <!--把控制器交给spring-->
   <bean id="userController" class="di.UserController">
   <!--
       1.一定要在UserController里面注入的属性提供getter和setter方法，默认使用setter方法注入。
       name:setUserService方法名  去掉set首字母变小写
       ref=引用其他bean的id
    -->
    <!--注入service-->
       <property name="userService" ref="userService"/>
   </bean>

   <!--把控制器交给spring-->
   <bean id="userService" class="di.UserServiceImpl">
       <!--注入dao-->
       <property name="userDao" ref="userDao"/>
   </bean>

   <!--把控制器交给spring-->
   <bean id="userDao" class="di.UserDaoImpl"/>
</beans>
```
**set方法注入**
```xml
<bean name="person" class="cgp.model.Person">
    <!-- value值为基本类型 -->
    <property name="name" value="jack"/>
    <property name="age" value="18"/>
</bean>
```
**引用类型值注入ref**
```xml
<bean name="person" class="cgp.model.Person">
    <property name="name" value="jack"/>
    <property name="age" value="18"/>
    <property name="car" ref="car"/>
</bean>
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
```
**单个有参构造方法注入**
```java
//在Person中创建有参构造函数
public Person(String name, Car car) {
    this.name = name;
    this.car = car;
    System.out.println("Person的有参构造");
}
```
配置xml
```xml
<bean name="person" class="cgp.model.Person">
    <constructor-arg name="name" value="chen"/>
    <constructor-arg name="car" ref="car"/>
</bean>
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
```
**index属性:按参数索引注入**

参数名一致,但位置不一致时,使用index

```java
public Person(String name, Car car) {
    this.name = name;
    this.car = car;
    System.out.println("Person(String name, Car car)");
}
//这两个构造函数的参数名相同,位置不同
public Person(Car car,String name){
    this.name = name;
    this.car = car;
    System.out.println("Person(Car car,String name)");
}
```
配置xml：使用`index`确定调用哪个构造函数
```xml
<bean name="person" class="cgp.model.Person">
    <constructor-arg name="name" value="chen" index="1"/>
    <constructor-arg name="car" ref="car" index="0"/>
</bean>
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
```
**type属性:按参数类型注入**

参数名和位置一致，但类型不一致时，使用`type`

```java
public Person(Car car,String name){
    this.name = name;
    this.car = car;
    System.out.println("Person(Car car,String name)");
}

public Person(Car car,Integer name){
    this.name = name+"";
    this.car = car;
    System.out.println("Person(Car car,Integer name)");
}
```
配置：使用`type`指定参数的类型
```xml
<bean name="person" class="cgp.model.Person">
    <constructor-arg name="name" value="123" type="java.lang.Integer"/>
    <constructor-arg name="car" ref="car"/>
</bean>
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
```
**p名称空间注入**

导入p名称空间:

使用p:属性名 完成注入,走set方法

- 基本类型值:  p:属性名="值"
- 引入类型值:  P:属性名-ref="bean名称"
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--1.第一步配置文件中 添加命名空间p
    xmlns:p="http://www.springframework.org/schema/p"
    -->
    <!--使用p命名空间进行赋值-->
    <bean name="person" class="cgp.model.Person" p:name="chen" p:age="18" p:car-ref="car"/>
    <bean name="car" class="cgp.model.Car">
        <property name="name" value="大众"/>
        <property name="color" value="白色"/>
    </bean>
</beans>
```
**spel注入**

Spring Expression Language：spring表达式语言<br />value="#{}"都是使用value:<br />{}里面写整形 `#{100+100*2}`<br />{}写字符串：`#{'Manaphy'}`<br />方法调用：`#{'中华人民共和国'.substring(1,2)}`<br />调用静态方法：`#{T(类).方法}`<br />调用对象的属性：`#{user.name}`

配置方式:

```xml
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
<!--利用spel引入car的属性-->
<bean name="person" class="cgp.model.Person" p:car-ref="car">
    <property name="name" value="#{car.name}"/>
    <property name="age" value="#{person.age}"/>
</bean>
<!--注入日期类型：默认支持 yyyy/MM/dd的日期格式的字符串转Date-->
<bean id="user" class="cgp.model.User">
    <property name="date" value="#{'2012/12/12'}"/>
    <property name="date1" value="#{new java.util.Date()}"/>
    <!--spel支持运算-->
    <property name="uid" value="#{100+12*2}"/>
    <!--spel支持访问其他bean属性-->
    <property name="name" value="#{car.name}"/>
    <!--spel调用静态方法 T(类名).方法()-->
    <property name="password" value="#{T(java.util.UUID).randomUUID().toString()}"/>
</bean>
```
**复杂类型注入**
```java
@Data
public class TestCollection {
    private Object[] arrs;
    private List<Object> list;
    private Map<String,Object> map;
    private Properties properties;
}
```
配置
```xml
<bean name="car" class="cgp.model.Car">
    <property name="name" value="大众"/>
    <property name="color" value="白色"/>
</bean>
<bean name="testColl" class="cgp.model.TestCollection">
    <!--数组变量注入-->
    <property name="arrs">
        <list>
            <value>数组1</value>
            <!--引入其他类型-->
            <ref bean="car"/>
        </list>
    </property>
    <!--集合变量赋值-->
    <property name="list">
        <list>
            <value>集合1</value>
            <!--集合变量内部包含集合-->
            <list>
                <value>集合中的集合1</value>
                <value>集合中的集合2</value>
                <value>集合中的集合3</value>
            </list>
            <ref bean="car"/>
        </list>
    </property>
    <!--map赋值-->
    <property name="map">
        <map>
            <entry key="car" value-ref="car"/>
            <entry key="name" value="保时捷"/>
            <entry key="age" value="11"/>
        </map>
    </property>
    <!--properties赋值-->
    <property name="properties">
        <props>
            <prop key="name">age</prop>
            <prop key="age">111</prop>
        </props>
    </property>
</bean>
```
**在spring的配置文件中加载**

db.properties:

```properties
jdbc.username=root
jdbc.password=1111
jdbc.url=jdbc:mysql://localhost:3306/shop?serverTimezone=GMT%2B8
jdbc.driverclass=com.mysql.cj.jdbc.Driver
```

```xml
<context:property-placeholder location="classpath:conf/*.properties"/>
```
然后通过以下方式可以使用里面的值
```xml
<property name="driverClassName" value="${jdbc.username}"></property>
<property name="password" value="${jdbc.password}"></property>
<property name="url" value="${jdbc.url}"/>
```
## 2.3 基于注解管理Bean
Spring 通过注解实现自动装配的步骤如下：

1. 引入依赖
2. 开启组件扫描
3. 使用注解定义 Bean
4. 依赖注入
### 2.3.1 开启组件扫描
Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    <!--开启组件扫描功能-->
    <context:component-scan base-package="com.cgp.spring6"></context:component-scan>
</beans>
```
注意：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 \<beans\> 中添加 context 相关的约束。

**情况一：最基本的扫描方式**

```xml
<context:component-scan base-package="com.atguigu.spring6">
</context:component-scan>
```
**情况二：指定要排除的组件**
```xml
<context:component-scan base-package="com.atguigu.spring6">
  <!-- context:exclude-filter标签：指定排除规则 -->
  <!-- 
  type：设置排除或包含的依据
  type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
  type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
  -->
  <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
  <!--<context:exclude-filter type="assignable" expression="com.atguigu.spring6.controller.UserController"/>-->
</context:component-scan>
```
**情况三：仅扫描指定组件**
```xml
<context:component-scan base-package="com.atguigu" use-default-filters="false">
  <!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 -->
  <!-- use-default-filters属性：取值false表示关闭默认扫描规则 -->
  <!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 -->
  <!-- 
  type：设置排除或包含的依据
  type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
  type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
  -->
  <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
  <!--<context:include-filter type="assignable" expression="com.atguigu.spring6.controller.UserController"/>-->
</context:component-scan>
```
### 2.3.2 使用注解定义 Bean
Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。

| **注解** | **说明** |
| :-- | :-- |
| @Component | 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 |
| @Repository | 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |
| @Service | 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |
| @Controller | 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |

### 2.3.3 @Autowired注入
单独使用@Autowired注解，**默认根据类型装配**。【默认是byType】

**属性注入**

```java
@Service
public class UserService {

    @Autowired
    private UserDao userDao;
}
```
**set注入**
```java
@Service
public class UserService {

    private UserDao userDao;

    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```
**构造方法注入**
```java
@Service
public class UserService {

    private UserDao userDao;

    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

}
```
**形参上注入**
```java
@Service
public class UserService {

    private UserDao userDao;

    public UserService(@Autowired UserDao userDao) {
        this.userDao = userDao;
    }
}
```
**只有一个构造函数，无注解**
> 当有参数的构造方法只有一个时，@Autowired注解可以省略。

```java
@Service
public class UserService {

    private UserDao userDao;

    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
}
```
**@Autowired注解和@Qualifier注解联合**
```java
@Service
public class UserService {

    @Autowired
    @Qualifier("userDaoImpl") // 如果有多个UserDao的bean,指定bean的名字
    private UserDao userDao;
}
```
### 2.3.4 @Resource注入
@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？

- @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)
- @Autowired注解是Spring框架自己的。
- **@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。**
- **@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。**
- @Resource注解用在属性上、setter方法上。
- @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。

@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【**如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。**】

**根据name注入**
```java
@Service
public class UserService {

    @Resource(name = "userDao")
    private UserDao userDao;
}
```
**name未知注入**
```java
@Service
public class UserService {

    @Resource
    private UserDao userDao;
}
```
**byType注入**
```java
@Service
public class UserService {

    @Resource
    private UserDao userDao1;
}
```
**总结：**

@Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个

## 2.4 Spring全注解开发
全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。
```java
package com.cgp.spring6.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.cgp.spring6")
public class Spring6Config {
}
```
```java
@Test
public void testAllAnnotation(){
    ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);
    UserController userController = context.getBean("userController", UserController.class);
    userController.out();
}
```
# 三、AOP面向切面编程
## 3.1 什么是AOP

1. 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP（面向对象编程）的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
2. AOP采取**横向抽取**机制，取代了传统**纵向继承**体系重复性代码
3. 经典应用：事务管理、性能监视、安全检查、缓存 、日志等
4. Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码对程序进行增强（不修改源码的情况下）
5. AspectJ是一个基于Java语言的**AOP**框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入
## 3.2 AOP的底层实现
Srping框架的AOP技术底层也是采用的代理技术，代理的方式提供了两种

1. 基于JDK的动态代理

必须是面向接口的，只有实现了具体接口的类才能生成代理对象

2. 基于CGLIB动态代理<br />对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式

Spring的传统AOP中根据类是否实现接口，来采用不同的代理方式

1. 如果实现类接口，使用JDK动态代理完成AOP
2. 如果没有实现接口，采用CGLIB动态代理完成AOP
## 3.3 动态代理
### 3.3.1 手动实现
```java
public interface Worker {
    void workInDay(double money);
    void workInNight(double money);
}
```
```java
public class XJJ implements Worker{

    @Override
    public void workInDay(double money) {
        System.out.println("上白班-->"+money);
    }

    @Override
    public void workInNight(double money) {
        System.out.println("上夜班-->"+money);
    }
}
```
```java
public class XJJProxy implements Worker{
    private XJJ xjj;

    public XJJProxy() {
        this.xjj=new XJJ();
    }

    @Override
    public void workInDay(double money) {
        System.out.println("开启白班事物");
        xjj.workInDay(money);
        System.out.println("提交白班事物");
    }

    @Override
    public void workInNight(double money) {
        System.out.println("开启夜班事物");
        xjj.workInNight(money);
        System.out.println("提交夜班事物");
    }
}
```
```java
public class DemoXJJ {
    public static void main(String[] args) {
        XJJProxy xjjProxy=new XJJProxy();
        xjjProxy.workInDay(1000);
        xjjProxy.workInNight(1500);
    }
}
```
### 3.3.2 JDK动态代理
```java
public class DemoTest {
    //jdk的代理 需要接口实现
    public static void main(String[] args) {
        /**
         * 第一个参数:是类加载器
         * 第二个参数:目标类的父接口数组
         * 第三个参数:回调函数 当执行目标类的任意方法 都会走该方法
         */
        Worker proxyInstance = (Worker)Proxy.newProxyInstance(XJJ.class.getClassLoader(), XJJ.class.getInterfaces(), new InvocationHandler() {
            /**
             *
             * @param proxy 生成的代理类对象  一般不使用该对象
             * @param method 目标类正在执行的方法对象
             * @param args 目标类正在执行的方法的参数
             * @return
             * @throws Throwable
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method.getName() + "--->方法执行之前 记录日志 开启事物");
                Object invoke = method.invoke(XJJ.class.newInstance(), (double) args[0] / 2);
                System.out.println("--->方法执行之后 记录日志 提交事物");
                return invoke;
            }
        });
        proxyInstance.workInDay(1000);
        proxyInstance.workInNight(1500);
    }
}
```
### 6.3.3 CGLIB字节码增强
```java
public class DemoCglib {
    //cglib动态代理  基于子类
    public static void main(String[] args) {
        //1.获得代理类的核心类Enhancer对象
        Enhancer enhancer = new Enhancer();
        //2.设置父类(目标类),setSuperclass()方法,底层是创建目标类的子类
        enhancer.setSuperclass(XJJ.class);
        //3.设置回调函数enhancer.setCallback(new MethodInterceptor())
        enhancer.setCallback(new MethodInterceptor() {
            /**
             *
             * @param o 代理对象
             * @param method 正在执行的目标方法对象
             * @param objects 方法的实参
             * @param methodProxy 方法得当代理对象
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println("执行目标方法之前-->"+method.getName());
                Object invoke = method.invoke(XJJ.class.newInstance(), (double)objects[0]/2);
                //invoke就是方法的返回值
                System.out.println("执行目标方法之后-->"+invoke);
                return invoke;
            }
        });
        //4.创建代理对象create()方法
        XJJ o = (XJJ) enhancer.create();
        //5.测试
        o.workInDay(1000);
        o.workInNight(1500);
    }
}
```
## 3.4 AOP的开发中的相关术语

1. Joinpoint(连接点) -- 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点
2. Pointcut(切入点)     -- 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义
3. Advice(通知/增强) -- 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)   **通知就定义了，需要做什么，以及在某个连接点的什么时候做。** **上面的切点定义了在哪里做**
4. Introduction(引介)   -- 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field
5. Target(目标对象)      -- 代理的目标对象
6. Weaving(织入)    -- 是指把增强应用到目标对象来创建新的代理对象的过程
7. Proxy（代理）     -- 一个类被AOP织入增强后，就产生一个结果代理类
8. Aspect(切面)         -- 是切入点和通知的结合，以后咱们自己来编写和配置的
## 3.5 spring aop编程
```java
public interface UserService {
    int add();
    void delete();
    void update();
    void query();
}
```
```java
public class UserServiceImpl implements UserService {

    @Override
    public int add() {
        System.out.println("add");
        return 100;
    }

    @Override
    public void delete() {
        System.out.println("delete");
    }

    @Override
    public void update() {
        System.out.println("update");
    }

    @Override
    public void query() {
        System.out.println("query");
    }
}
```
```java
/**
 * 环绕通知 org.aopalliance.intercept.MethodInterceptor
 * 在目标方法执行前后实施增强
 */
public class MyAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation methodInvocation) {
        Object o = null;
        try {
            System.out.println("前置通知-->" + methodInvocation.getMethod().getName());
            o = methodInvocation.proceed();//执行目标方法
            System.out.println("后置通知-->" + o);//获得方法的返回值
        } catch (Throwable throwable) {
            System.out.println("异常通知-->");//回滚事物
            throwable.printStackTrace();
        } finally {
            //提交事物,释放资源
            System.out.println("最终通知-->");
            return o;
        }
    }
}
```
```xml
<beans>
		<!--配置目标类-->
    <bean id="userService" class="aop.service.impl.UserServiceImpl"/>
    <!--配置通知类-->
    <bean id="myAdvice" class="aop.MyAdvice"/>
    <!--aop配置
    proxy-target-class:默认会根据目标类有无接口来进行选用jdk的动态还是cglib动态代理，有接口选jdk的动态代理，无选择cglib动态代理。
    指定true:强制使用cglib
    -->
    <aop:config proxy-target-class="true">
        <!--配置切点表达式，根据该切点表达式可以找到你要拦截的类的方法
            id;指定id
            expression:切点表达式
            execution(public * aop.service.impl.*.*(..))
            public指方法的访问权限修饰符  默认public可以不写
            *表示方法的返回值是任意的。int  String  void  ....
            aop.service.impl:指拦截的包路径
            *:第一个*表示包下面的任意类
            *：表示该包下面的任意方法
            (..):表示方法的形参任意
        -->
        <aop:pointcut id="cut" expression="execution(* aop.service.impl.*.add*(..))"/>
        <aop:pointcut id="cut2" expression="execution(* aop.service.impl.*.delete*(..))"/>
        <!--配置切面
        advice-ref:指向通知的id
        pointcut-ref:指向切点表达式的id
        -->
        <aop:advisor advice-ref="myAdvice" pointcut-ref="cut"/>
        <aop:advisor advice-ref="myAdvice" pointcut-ref="cut2"/>
    </aop:config>
</beans>
```
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:aop/spring-aop.xml")
public class DemoAop {
    @Autowired
    private UserService userService;

    @Test
    public void run(){
        userService.add();
        userService.delete();
        userService.update();
        userService.query();
    }
}
```
## 3.6 AspectJ编程
### 3.6.1 AspectJ介绍

- AspectJ是一个基于Java语言的AOP框架
- Spring2.0以后新增了对AspectJ切点表达式支持
- [@AspectJ ](/AspectJ ) 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面 
- 主要用途：自定义开发

**新版本Spring框架，建议使用AspectJ方式来开发AOP**
### 3.6.2 AspectJ 通知类型

- aop联盟定义通知类型，具有特性接口，必须实现，从而确定方法名称。
- aspectj 通知类型，只定义类型名称。方法格式。
### 3.6.3 基于xml实现
略...
### 3.6.4 基于注解
切面类 aop的配置
```xml
<!--开启注解扫描-->
<context:component-scan base-package="aspectj_anno"/>
<!--开启aop注解-->
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>
```
修改实现类使用注解

修改切面类

```java
//Aspect 声明切面，修饰切面类，从而获得通知
@Component//<bean id="myAdvice" class="aspectj.MyAdvice"/>
@Aspect//<aop:aspect ref="myAdvice">
public class MyAdvice {
    //配置一个公共的切点表达式
    @Pointcut("execution(* aspectj_anno.service.impl.*.*(..))")
    public void myCut(){}

    //前置通知<aop:before method="myBefore" pointcut="execution(* aspectj_anno.service.impl.*.*(..))"/>
    @Before("execution(* aspectj_anno.service.impl.*.*(..))")
    public void myBefore(JoinPoint joinPoint){
        System.out.println("前置通知-->"+joinPoint.getSignature().getName());
    }
    //后置通知  获得方法的返回值
    //Object res  第二个形参表示方法的返回值  参数名需要进行配置
    @AfterReturning(value = "execution(* aspectj_anno.service.impl.*.*(..))",returning = "res")
    public void afterReturing(JoinPoint joinPoint,Object res){
        System.out.println(res+"后置通知-->"+joinPoint.getSignature().getName());
    }
    //异常通知
    //Throwable e 表示异常对象  形参名需要配置
    @AfterThrowing(value="myCut()",throwing = "e")
    public void afterThrowing(JoinPoint joinPoint,Throwable e){
        System.out.println(e.getMessage()+"异常通知-->"+joinPoint.getSignature().getName());
    }
    //最终通知
    @After("myCut()")
    public void after(){
        System.out.println("最终通知-->");
    }
    //环绕通知
    @Around("myCut()")
    public Object around(ProceedingJoinPoint joinPoint){
        Object proceed=null;
        try {
            System.out.println("around-->前置通知");
            //手动执行目标方法
            proceed = joinPoint.proceed();
            System.out.println("around-->后置通知");
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println("around-->异常通知");
        }finally {
            System.out.println("around-->最终通知");
            return proceed;
        }
    }
}
```
```java
@RunWith(SpringJUnit4ClassRunner.class)
public class DemoApsectj {
    @Resource
    private UserService userService;
    @Test
    public void run(){
        userService.add();
    }
}
```
测试类同上,结果如下
```
around-->前置通知
前置通知-->add
UserServiceImpl.add
around-->后置通知
around-->最终通知
最终通知-->
null后置通知-->add
```
# 四、事务
## 4.1 Spring JDBC 数据访问
> Spring JDBC是Spring所提供的持久层技术,它的主要目标是降低使用JDBC API的门槛,以一种更直接,更简介,更简单的方式使用JDBC API, 在Spring JDBC里,仅需做那些与业务相关的DML操作,而将资源获取,Statment创建,资源释放以及异常处理等繁杂而乏味的工作交给Spring JDBC.
> 虽然ORM的框架已经成熟丰富,但是JDBC的灵活,直接的特性,依然让他拥有自己的用武之地,如在完全依赖查询模型动态产生查询语句的综合查询系统中,Hibernaye,MyBatis,JPA等框架都无法使用,这里JDBC是唯一的选择.

## 4.2 JdbcTemplate的简单使用
```java
public class DemoJdbcTemplate {
    /**
     * spring给我们提供了一个类：JdbcTemplate
     * jdbcTemplate.queryForObject(); 返回对象
     * jdbcTemplate.query(); 返回一个List
     * jdbcTemplate.update(); 新增、修改、删除
     */
    @Test
    public void run() throws PropertyVetoException {
        //创建c3p0链接池
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        //设置必要的信息
        dataSource.setJdbcUrl("jdbc:mysql:///mydb?serverTimezone=GMT%2B8");
        dataSource.setUser("root");
        dataSource.setPassword("1111");
        dataSource.setDriverClass("com.mysql.cj.jdbc.Driver");
        //创建jdbcTemplate对象
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.update("insert into user(uname,upwd) values (?,?)", "chen", "1234");
    }
}
```
## 4.3 使用Spring管理JdbcTemplate
```java
@Data
public class User {
    private int uid;
    private String uname;
    private String upwd;
    private Date birthday;

}
```
```java
public interface UserDao {
    int add(User user);//增
    int deleteById(int uid);//删
    int update(User user);//改
    User queryById(int uid);//查
    List<User> queryAll();//查询所有
    int count();//查询条数
}
```
```java
@Repository
public class UserDaoImpl implements UserDao {
    @Autowired //自动装配
    private JdbcTemplate jdbcTemplate;

    @Override
    public int add(User user) {
        return jdbcTemplate.update("insert into user(uname,upwd) values (?,?)", user.getUname(), user.getUpwd());
    }

    @Override
    public int deleteById(int uid) {
        return jdbcTemplate.update("delete from user where uid=?", uid);
    }

    @Override
    public int update(User user) {
        return jdbcTemplate.update("update user set uname=? where uid=?", user.getUname(), user.getUid());

    }

    /**
     * BeanPropertyRowMapper 可以把结果集封装到对象里面
     * 通过属性名和列名一致来调用setter进行设置值。
     */
    @Override
    public User queryById(int uid) {
        return jdbcTemplate.queryForObject("select * from user where uid=?",
                new BeanPropertyRowMapper<>(User.class),uid);
    }

    @Override
    public List<User> queryAll() {
        return jdbcTemplate.query("select * from user",new BeanPropertyRowMapper<>(User.class));
    }

    @Override
    public int count() {
        return jdbcTemplate.queryForObject("select count(uid) from user",Integer.class);
    }
}
```
```xml
<!--加载db.properties-->
<context:property-placeholder location="classpath:db.properties"/>
<!--开启注解扫描-->
<context:component-scan base-package="jdbctemplate2"/>
<!--配置数据源-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
      p:user="${jdbc.user}"
      p:password="${jdbc.password}"
      p:jdbcUrl="${jdbc.url}"
      p:driverClass="${jdbc.driverClass}"/>
<!--配置jdbcTemplate-->
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"
      p:dataSource-ref="dataSource"/>
```
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:jdbctemplate2/spring-jdbc.xml")
public class DemoJdbcTemplate {
    @Autowired
    private UserDao userDao;
    @Test
    public void runAdd(){
        User user=new User();
        user.setUname("chen");
        user.setUpwd("1213");
        int row = userDao.add(user);
        System.out.println("row = " + row);
    }
    @Test
    public void runDelete(){
        int row = userDao.deleteById(5);
        System.out.println("row = " + row);
    }
    @Test
    public void runUpdate(){
        User user=new User();
        user.setUid(3);
        user.setUname("chen");
        int row = userDao.update(user);
        System.out.println("row = " + row);
    }
    @Test
    public void runQueryObject(){
        User user = userDao.queryById(1);
        System.out.println("user = " + user);
    }
    @Test
    public void runQueryAll(){
        List<User> users = userDao.queryAll();
        System.out.println(users);
    }
    @Test
    public void runQueryCount(){
        System.out.println(userDao.count());
    }
}
```
使用JdbcDaoSupport,可以让我们的dao继承JdbcDaoSupport，然后注入DataSource或者JdbcTemplate，我们可以抽取一个BaseDao父类：让我们的dao类继承 BaseDao
```java
@Component
public class BaseDao extends JdbcDaoSupport {
    @Autowired
    private DataSource dataSource;
    //在该类初始化的时候,给父类设置dataSource
    @PostConstruct
    public void init(){
        System.out.println("BaseDao.init");
        super.setDataSource(dataSource);
    }
}
```
```java
@Repository
public class UserDaoImpl2 extends BaseDao implements UserDao {
//JdbcDaoSupport是Spring给我们提供的一个类，我们可以让我们的dao类继承该类 然后给该类输入数据源或者模板类
    @Override
    public int add(User user) {
        return this.getJdbcTemplate().update("insert into user(uname,upwd) values (?,?)", user.getUname(), user.getUpwd());
    }

    @Override
    public int deleteById(int uid) {

        return this.getJdbcTemplate().update("delete from user where uid=?", uid);
    }

    @Override
    public int update(User user) {

        return this.getJdbcTemplate().update("update user set uname=? where uid=?", user.getUname(), user.getUid());

    }


    @Override
    public User queryById(int uid) {
        return this.getJdbcTemplate().queryForObject("select * from user where uid=?",
                new BeanPropertyRowMapper<>(User.class),uid);
    }

    @Override
    public List<User> queryAll() {
        return this.getJdbcTemplate().query("select * from user",new BeanPropertyRowMapper<>(User.class));
    }

    @Override
    public int count() {
        return this.getJdbcTemplate().queryForObject("select count(uid) from user",Integer.class);
    }
}
```
```xml
<context:property-placeholder location="db.properties"/>
<context:component-scan base-package="jdbctemplate2"/>
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
      p:user="${jdbc.user}"
      p:password="${jdbc.password}"
      p:jdbcUrl="${jdbc.url}"
      p:driverClass="${jdbc.driverClass}"/>
```
测试类同上
## 4.4 Spring事务管理
> 事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：(一般只需掌握前两种)

### 事务的传播行为

- **PROPAGATION_REQUIRED**<br />表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务
- **PROPAGATION_SUPPORTS**<br />表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行
- **PROPAGATION_MANDATORY**<br />表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常
- **PROPAGATION_REQUIRED_NEW**<br />表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起
- **PROPAGATION_NOT_SUPPORTED**<br />表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。
- **PROPAGATION_NEVER**<br />表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常
- **PROPAGATION_NESTED**<br />表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务
### 事务的特性(ACID)

- **原子性**（atomicity）

事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于其数据修改，要么全部执行，要么全部不执行。

- **一致性**（consistency）

事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。

- **隔离性**（isolation）

一个事务的执行不能被其他事务所影响。企业级的数据库每一秒钟都可能应付成千上万的并发访问，因而带来了并发控制的问题。由数据库理论可知，由于并发访问，在不可预料的时刻可能引发事务的并发问题

- **持久性**（durability）

一个事务一旦提交，事物的操作便永久性的保存在DB中。即使此时再执行回滚操作也不能撤消所做的更改
### 事务的并发问题

1. **脏读**（Dirty Read）

一个事务读取到了另一个事务未提交的数据操作结果。这是相当危险的，因为很可能所有的操作都被回滚。

2. **不可重复读**（虚读）（NonRepeatable Read）

一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。

3. **幻读**（Phantom Read）

事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据，这是因为在两次查询过程中有另外一个事务插入数据造成的
### 事务的隔离级别

1. 读未提交  Read uncommitted：最低级别，以上情况均无法保证。
2. 读已提交  Read committed：可避免脏读情况发生。
3. 可重复读  Repeatable read：可避免脏读、不可重复读情况的发生。不可以避免幻读。
4. 串行化读  Serializable：事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重

#### 转账案例
1.项目名:spring-tx 引入jar包 复制数据库配置db.properties<br />2.创建数据库<br />3.创建dao接口

```java
public interface AccountDao {
    int descMoney(int from,double money);
    int addMoney(int to,double money);
}
```
4.创建dao实现类
```java
@Repository
public class AccountDaoImpl implements AccountDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Override
    public int descMoney(int from, double money) {
        String sql="update account set money=money-? where id=?";
        return jdbcTemplate.update(sql,money,from);
    }

    @Override
    public int addMoney(int to, double money) {
        String sql="update account set money=money+? where id=?";
        return jdbcTemplate.update(sql,money,to);
    }
}
```
5.创建service接口
```java
public interface AccountService {//转账业务
    boolean transfer(int from,int to,double money);
}
```
6.创建service实现类
```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;
    @Override
    public boolean transfer(Integer from, Integer to, Double money) {
        accountDao.descMoney(from,money);
        accountDao.addMoney(to,money);
        return true;
    }
}
```
7.添加ioc配置文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"
       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd">

    <context:property-placeholder location="db.properties"/>
    <context:component-scan base-package="spring_tx"/>
    <!--配置数据源-->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
          p:user="${jdbc.user}"
          p:password="${jdbc.password}"
          p:jdbcUrl="${jdbc.url}"
          p:driverClass="${jdbc.driverClass}"/>
    <!--配置JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--1.配置平台事物管理器
    DataSourceTransactionManager 用于 JDBC和mybatis 的事务管理
    HibernateTransactionManager 用于 Hibernate 的事务管理
    JpaTransactionManager 用于 Jpa 的事务管理 -->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!--2.配置事务详情/属性 (传播行为 超时时间 是否可读)-->
    <!--配置事务通知/属性:transaction-manager="transactionManager"：指向事务平台管理器-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
        <!--配置事务属性-->
        <tx:attributes>
            <!--
            tx:method配置事务方法
            propagation:事务的传播行为 一般增删改配置REQUIRED 查询配置SUPPORTS
            isolation:隔离级别 一般默认不配置
            timeout="-1" 默认-1 采取数据库默认的超时时间 一般默认不配置
            read-only="false"：是否只读  默认false 查询配置true
            no-rollback-for:遇到什么异常不回滚  一般默认不配置
            rollback-for：遇到什么异常回滚  一般默认不配置
            name:配置的方法名 采取通配符的方式 配置业务层的方法名 事务在业务层开启
            -->
            <tx:method name="add*" propagation="REQUIRED"/>
            <tx:method name="delete*" propagation="REQUIRED"/>
            <tx:method name="update*" propagation="REQUIRED"/>
            <tx:method name="modify*" propagation="REQUIRED"/>
            <tx:method name="trans*" propagation="REQUIRED"/>
            <tx:method name="change*" propagation="REQUIRED"/>
            <tx:method name="query*" propagation="SUPPORTS" read-only="true"/>
            <tx:method name="*" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>
    <!--3.aop编程-->
    <aop:config>
        <aop:pointcut id="cut" expression="execution(* spring_tx.service.impl.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="cut"/>
    </aop:config>
</beans>
```
8.测试
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:spring_tx/spring-tx.xml")
public class DemoTransfer {
    @Autowired
    private AccountService accountService;
    @Test
    public void run(){
        boolean transfer = accountService.transfer(1, 2, (double) 500);
        System.out.println("transfer = " + transfer);
    }
}
```
#### Spring XML配置声明事务
**TransactionManager**

在不同平台，操作事务的代码各不相同，因此spring提供了一个 TransactionManager 接口：

- DataSourceTransactionManager 用于 JDBC和mybatis 的事务管理
- HibernateTransactionManager 用于 Hibernate 的事务管理
- JpaTransactionManager 用于 Jpa 的事务管理

**接口的定义**

事务的属性介绍：这里定义了传播行为、隔离级别、超时时间、是否只读

```java
package org.springframework.transaction;
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0; //支持当前事务，如果不存在，就新建一个
    int PROPAGATION_SUPPORTS = 1; //支持当前事务，如果不存在，就不使用事务
    int PROPAGATION_MANDATORY = 2; //支持当前事务，如果不存在，就抛出异常
    int PROPAGATION_REQUIRES_NEW = 3;//如果有事务存在，挂起当前事务，创建一个新的事物
    int PROPAGATION_NOT_SUPPORTED = 4;//以非事务方式运行，如果有事务存在，挂起当前事务
    int PROPAGATION_NEVER = 5;//以非事务方式运行，如果有事务存在，就抛出异常
    int PROPAGATION_NESTED = 6;//如果有事务存在，则嵌套事务执行
    
    int ISOLATION_DEFAULT = -1;//默认级别 MYSQL: 默认为REPEATABLE_READ级别;SQLSERVER: 默认为READ_COMMITTED
    int ISOLATION_READ_UNCOMMITTED = 1;//读取未提交数据(会出现脏读, 不可重复读) 基本不使用
    int ISOLATION_READ_COMMITTED = 2;//读取已提交数据(会出现不可重复读和幻读)
    int ISOLATION_REPEATABLE_READ = 4;//可重复读(会出现幻读)
    int ISOLATION_SERIALIZABLE = 8;//串行化
    
    int TIMEOUT_DEFAULT = -1;//默认是-1，不超时，单位是秒

    //事务的传播行为
    int getPropagationBehavior();
    //事务的隔离级别
    int getIsolationLevel();
    //事务超时时间
    int getTimeout();
    //是否只读
    boolean isReadOnly();
    String getName();
}
```
#### 使用注解方式添加事务
修改service实现类添加 **@Transactional** 注解
```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;
    @Override
    @Transactional//既可以写在方法上  也可以写在类上  写在类上表示该类的所有方法都加事务
//    @Transactional(rollbackFor = {Exception.class})//阿里规范写法,需指定rollbackFor
//    @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT,timeout = -1,readOnly = 											 false,rollbackFor = {Exception.class},noRollbackFor = {})
    public boolean transfer(Integer from, Integer to, Double money) {
        accountDao.descMoney(from,money);
        accountDao.addMoney(to,money);
        return true;
    }
}
```
配置xml
```xml
    <context:property-placeholder location="db.properties"/>
    <context:component-scan base-package="spring_tx_anno"/>
    <!--配置数据源-->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
          p:user="${jdbc.user}"
          p:password="${jdbc.password}"
          p:jdbcUrl="${jdbc.url}"
          p:driverClass="${jdbc.driverClass}"/>
    <!--配置JdbcTemplate-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!--配置平台事物管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!--注入数据源-->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!--开启事务驱动-->
    <tx:annotation-driven transaction-manager="transactionManager"/>
```
测试类同上
